from datetime import date
import json
import pathlib
from agent.llm_client import LLMClient
from agent.prompt_manager import PromptManager

def code_generate(requirement: str, task_description: str = "", model_name: str = "qwen2.5-coder:7b") -> str:
    """
    根据需求和任务生成代码
    
    Args:
        requirement: 用户的总体需求
        task_description: 具体任务描述（若有多个任务）
        model_name: 使用的模型
    
    Returns:
        生成的JSON格式代码结果
    """
    print("[CODER] 生成代码...")
    
    # 加载prompt模板
    pm = PromptManager()
    prompt = pm.get("coder", 
                   requirement=requirement, 
                   task_description=task_description)
    
    # 调用LLM
    client = LLMClient(
        model_name=model_name,
        temperature=0.2,
        max_tokens=4096
    )
    
    result = client.generate(prompt, response_format="json")
    return result

def code_aggregate(task_modules: list, project_name: str = "project") -> dict:
    """
    将多个任务的代码汇总为多文件项目结构
    
    Args:
        task_modules: 包含多个任务代码的列表，每项为 {"task_name": ..., "code": ..., "filename": ...}
        project_name: 项目名称
    
    Returns:
        字典，key为文件名，value为代码内容 {"main.py": "code1", "utils.py": "code2", ...}
    """
    file_dict = {}
    main_file_assigned = False
    
    # 如果只有一个任务，直接作为main.py
    if len(task_modules) == 1:
        module = task_modules[0]
        code = module.get("code", "")
        file_dict["main.py"] = f"# Project: {project_name}\n# Auto-generated by Code Agent\n\n{code}"
        return file_dict
    
    # 多任务情况：为每个任务生成独立文件
    for idx, module in enumerate(task_modules):
        task_name = module.get("task_name", f"task_{idx}")
        code = module.get("code", "")
        
        # 优先使用LLM返回的filename
        if "filename" in module and module["filename"]:
            filename = module["filename"]
            # 确保有.py后缀
            if not filename.endswith(".py"):
                filename += ".py"
        else:
            # 根据task_name智能生成文件名
            filename = _generate_filename_from_task(task_name, idx)
        
        # 检测是否应该作为main.py
        if not main_file_assigned and _is_main_task(task_name, idx, len(task_modules)):
            filename = "main.py"
            main_file_assigned = True

        # 若已经有入口文件，再出现main.py则退回为普通模块名，避免多个main
        if main_file_assigned and filename == "main.py":
            filename = _generate_filename_from_task(task_name, idx)
        
        # 检查文件名冲突
        original_filename = filename
        counter = 1
        while filename in file_dict:
            name, ext = original_filename.rsplit(".", 1) if "." in original_filename else (original_filename, "py")
            filename = f"{name}_{counter}.{ext}"
            counter += 1
        
        # 添加文件头注释
        file_content = f"# Project: {project_name}\n"
        file_content += f"# Module: {task_name}\n"
        file_content += "# Auto-generated by Code Agent\n\n"
        file_content += code
        
        file_dict[filename] = file_content
    
    # 如果没有main.py，将第一个文件重命名为main.py
    if "main.py" not in file_dict and file_dict:
        first_key = list(file_dict.keys())[0]
        file_dict["main.py"] = file_dict.pop(first_key)
        print("[INFO] 未检测到主入口文件，已将第一个文件命名为 main.py")
    
    print(f"[INFO] 生成 {len(file_dict)} 个文件: {', '.join(file_dict.keys())}")
    return file_dict

def _is_main_task(task_name: str, idx: int, total: int) -> bool:
    """
    判断任务是否应该作为main.py主文件
    
    Args:
        task_name: 任务名称
        idx: 任务索引
        total: 总任务数
    
    Returns:
        是否为主任务
    """
    task_lower = task_name.lower()
    
    # 关键词匹配：包含main、主程序、入口等
    main_keywords = ["main", "主程序", "主入口", "入口", "启动", "运行", "程序入口", "entry"]
    if any(keyword in task_lower for keyword in main_keywords):
        return True
    
    # 如果是最后一个任务，通常是整合/主程序
    if idx == total - 1:
        integration_keywords = ["整合", "集成", "综合", "总", "完整"]
        if any(keyword in task_lower for keyword in integration_keywords):
            return True
    
    return False

def _generate_filename_from_task(task_name: str, idx: int) -> str:
    """
    根据任务名称智能生成文件名
    
    Args:
        task_name: 任务名称
        idx: 任务索引
    
    Returns:
        生成的文件名
    """
    # 常见的任务名到文件名的映射
    name_mapping = {
        "用户": "user",
        "用户管理": "user",
        "用户类": "user",
        "产品": "product",
        "产品管理": "product",
        "订单": "order",
        "订单管理": "order",
        "工具": "utils",
        "工具函数": "utils",
        "辅助函数": "utils",
        "帮助函数": "helpers",
        "配置": "config",
        "设置": "config",
        "数据库": "database",
        "模型": "models",
        "视图": "views",
        "控制器": "controller",
        "服务": "service",
        "测试": "test",
        "常量": "constants",
    }
    
    task_lower = task_name.lower()
    
    # 尝试映射匹配
    for key, value in name_mapping.items():
        if key in task_name or key in task_lower:
            return f"{value}.py"
    
    # 如果没有匹配，使用任务名转换
    # 去除常见的后缀词
    clean_name = task_name.replace("的实现", "").replace("功能", "").replace("模块", "")
    clean_name = clean_name.replace("类", "").replace("函数", "").strip()
    
    # 转换为合法的文件名
    filename = clean_name.replace(" ", "_").replace("/", "_").replace("（", "_").replace("）", "")
    filename = filename.replace("(", "_").replace(")", "_").lower()
    
    # 如果文件名为空或太短，使用索引
    if len(filename) < 2:
        filename = f"module_{idx}"
    
    return f"{filename}.py"

def code_aggregate_single_file(task_modules: list, project_name: str = "project") -> str:
    """
    将多个任务的代码汇总为单个文件（旧版本，保留作为兼容）
    
    Args:
        task_modules: 包含多个任务代码的列表，每项为 {"task_name": ..., "code": ...}
        project_name: 项目名称
    
    Returns:
        汇总后的代码字符串
    """
    # 如果只有一个任务，直接返回
    if len(task_modules) == 1:
        code = task_modules[0].get("code", "")
        return f"# Project: {project_name}\n# Auto-generated by Code Agent\n\n{code}"
    
    # 检测代码是否高度重复
    codes = [m.get("code", "").strip() for m in task_modules]
    unique_codes = list(set(codes))
    
    # 如果所有任务生成了相同的代码（去重后只剩1个），只保留一份
    if len(unique_codes) == 1:
        print("[WARNING] 检测到所有任务生成了相同代码，自动去重")
        return f"# Project: {project_name}\n# Auto-generated by Code Agent\n\n{unique_codes[0]}"
    
    # 如果大部分代码重复（重复率>70%），只保留不同的
    if len(unique_codes) / len(codes) < 0.3:
        print(f"[WARNING] 检测到高度重复代码（{len(codes)}个任务中有{len(unique_codes)}个不同），自动去重")
        aggregated_code = f"# Project: {project_name}\n"
        aggregated_code += "# Auto-generated by Code Agent\n\n"
        
        for idx, code in enumerate(unique_codes):
            aggregated_code += f"# Module {idx + 1}\n"
            aggregated_code += code + "\n\n"
        
        return aggregated_code
    
    # 否则按模块拼接（正常情况）
    aggregated_code = f"# Project: {project_name}\n"
    aggregated_code += "# Auto-generated by Code Agent\n\n"
    
    for idx, module in enumerate(task_modules):
        task_name = module.get("task_name", f"Task{idx}")
        code = module.get("code", "")
        
        # 为每个任务的代码添加模块标记
        aggregated_code += f"\n# " + "=" * 60 + "\n"
        aggregated_code += f"# Module {idx + 1}: {task_name}\n"
        aggregated_code += "# " + "=" * 60 + "\n"
        aggregated_code += code + "\n"
    
    return aggregated_code

def code_save(code_json: str, save_dir: str = "results/generated_code") -> str:
    """
    保存LLM生成的代码到本地文件
    Args:
        code_json: LLM生成的JSON字符串，包含代码和元信息
        save_dir: 代码保存目录，默认 "results/generated_code"
    
    Returns:
        保存的文件路径
    """
    try:
        json_data = json.loads(code_json)
        
        if json_data.get("status") != "success":
            raise ValueError("LLM did not return a successful status.")
        
        filename = json_data.get("filename", "generated_code.py")
        code = json_data.get("code", "")
        
        # 创建保存目录
        save_path = pathlib.Path(save_dir)
        save_path.mkdir(parents=True, exist_ok=True)
        
        file_path = save_path / filename
        
        # 写入代码到文件
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(code)
        
        print(f"[INFO] Code saved to {file_path}")
        return str(file_path)
    
    except json.JSONDecodeError:
        raise ValueError("Invalid JSON format from LLM.")
    except Exception as e:
        raise RuntimeError(f"Failed to save code: {e}")

def code_save_multi_file(file_dict: dict, project_name: str = "project", save_dir: str = "results/generated_code") -> dict:
    """
    保存多文件项目结构
    
    Args:
        file_dict: 文件字典，key为文件名，value为代码内容
        project_name: 项目名称
        save_dir: 保存根目录
    
    Returns:
        保存的文件路径字典 {"main.py": "path1", "utils.py": "path2", ...}
    """
    try:
        # 创建项目目录
        project_path = pathlib.Path(save_dir) / project_name
        project_path.mkdir(parents=True, exist_ok=True)
        
        saved_files = {}
        
        # 保存每个文件
        for filename, code in file_dict.items():
            file_path = project_path / filename
            
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(code)
            
            saved_files[filename] = str(file_path)
            print(f"[INFO] ✓ {filename} saved to {file_path}")
        
        print(f"[INFO] 项目 '{project_name}' 已保存 {len(saved_files)} 个文件到 {project_path}")
        return saved_files
    
    except Exception as e:
        raise RuntimeError(f"Failed to save multi-file project: {e}")

def code_save_aggregated(aggregated_code: str, project_name: str = "project", save_dir: str = "results/generated_code") -> str:
    """
    保存汇总后的多任务代码到单个文件（旧版本，保留作为兼容）
    
    Args:
        aggregated_code: 汇总后的代码
        project_name: 项目名称
        save_dir: 保存目录
    
    Returns:
        保存的文件路径
    """
    try:
        # 创建保存目录
        save_path = pathlib.Path(save_dir)
        save_path.mkdir(parents=True, exist_ok=True)
        
        filename = f"{project_name}.py"
        file_path = save_path / filename
        
        # 写入代码到文件
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(aggregated_code)
        
        print(f"[INFO] Aggregated code saved to {file_path}")
        return str(file_path)
    
    except Exception as e:
        raise RuntimeError(f"Failed to save aggregated code: {e}")
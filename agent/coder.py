from datetime import date
import json
import pathlib
from agent.llm_client import LLMClient
from agent.prompt_manager import PromptManager

def code_generate(requirement: str, task_description: str = "", model_name: str = "qwen2.5-coder:7b") -> str:
    """
    根据需求和任务生成代码
    
    Args:
        requirement: 用户的总体需求
        task_description: 具体任务描述（若有多个任务）
        model_name: 使用的模型
    
    Returns:
        生成的JSON格式代码结果
    """
    print("[CODER] 生成代码...")
    
    # 加载prompt模板
    pm = PromptManager()
    prompt = pm.get("coder", 
                   requirement=requirement, 
                   task_description=task_description)
    
    # 调用LLM
    client = LLMClient(
        model_name=model_name,
        temperature=0.2,
        max_tokens=4096
    )
    
    result = client.generate(prompt, response_format="json")
    return result

def code_aggregate(task_modules: list, project_name: str = "project") -> str:
    """
    将多个任务的代码汇总为一个项目
    
    Args:
        task_modules: 包含多个任务代码的列表，每项为 {"task_name": ..., "code": ...}
        project_name: 项目名称
    
    Returns:
        汇总后的代码
    """
    # 如果只有一个任务，直接返回
    if len(task_modules) == 1:
        code = task_modules[0].get("code", "")
        return f"# Project: {project_name}\n# Auto-generated by Code Agent\n\n{code}"
    
    # 检测代码是否高度重复
    codes = [m.get("code", "").strip() for m in task_modules]
    unique_codes = list(set(codes))
    
    # 如果所有任务生成了相同的代码（去重后只剩1个），只保留一份
    if len(unique_codes) == 1:
        print("[WARNING] 检测到所有任务生成了相同代码，自动去重")
        return f"# Project: {project_name}\n# Auto-generated by Code Agent\n\n{unique_codes[0]}"
    
    # 如果大部分代码重复（重复率>70%），只保留不同的
    if len(unique_codes) / len(codes) < 0.3:
        print(f"[WARNING] 检测到高度重复代码（{len(codes)}个任务中有{len(unique_codes)}个不同），自动去重")
        aggregated_code = f"# Project: {project_name}\n"
        aggregated_code += "# Auto-generated by Code Agent\n\n"
        
        for idx, code in enumerate(unique_codes):
            aggregated_code += f"# Module {idx + 1}\n"
            aggregated_code += code + "\n\n"
        
        return aggregated_code
    
    # 否则按模块拼接（正常情况）
    aggregated_code = f"# Project: {project_name}\n"
    aggregated_code += "# Auto-generated by Code Agent\n\n"
    
    for idx, module in enumerate(task_modules):
        task_name = module.get("task_name", f"Task{idx}")
        code = module.get("code", "")
        
        # 为每个任务的代码添加模块标记
        aggregated_code += f"\n# " + "=" * 60 + "\n"
        aggregated_code += f"# Module {idx + 1}: {task_name}\n"
        aggregated_code += "# " + "=" * 60 + "\n"
        aggregated_code += code + "\n"
    
    return aggregated_code

def code_save(code_json: str, save_dir: str = "results/generated_code") -> str:
    """
    保存LLM生成的代码到本地文件
    Args:
        code_json: LLM生成的JSON字符串，包含代码和元信息
        save_dir: 代码保存目录，默认 "results/generated_code"
    
    Returns:
        保存的文件路径
    """
    try:
        json_data = json.loads(code_json)
        
        if json_data.get("status") != "success":
            raise ValueError("LLM did not return a successful status.")
        
        filename = json_data.get("filename", "generated_code.py")
        code = json_data.get("code", "")
        
        # 创建保存目录
        save_path = pathlib.Path(save_dir)
        save_path.mkdir(parents=True, exist_ok=True)
        
        file_path = save_path / filename
        
        # 写入代码到文件
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(code)
        
        print(f"[INFO] Code saved to {file_path}")
        return str(file_path)
    
    except json.JSONDecodeError:
        raise ValueError("Invalid JSON format from LLM.")
    except Exception as e:
        raise RuntimeError(f"Failed to save code: {e}")

def code_save_aggregated(aggregated_code: str, project_name: str = "project", save_dir: str = "results/generated_code") -> str:
    """
    保存汇总后的多任务代码
    
    Args:
        aggregated_code: 汇总后的代码
        project_name: 项目名称
        save_dir: 保存目录
    
    Returns:
        保存的文件路径
    """
    try:
        # 创建保存目录
        save_path = pathlib.Path(save_dir)
        save_path.mkdir(parents=True, exist_ok=True)
        
        filename = f"{project_name}.py"
        file_path = save_path / filename
        
        # 写入代码到文件
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(aggregated_code)
        
        print(f"[INFO] Aggregated code saved to {file_path}")
        return str(file_path)
    
    except Exception as e:
        raise RuntimeError(f"Failed to save aggregated code: {e}")